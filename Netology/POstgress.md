После установки postgresql нужно инициализировать cluster.Ключ K подсчет контрольных сумм страниц памяти.
initdb -U postgres -K -D /путь_до_места где будут лежать все данные кластера
- При запуске psql выполняются два скрипта (при их наличии):
  - сначала общий системный скрипт psqlrc;
  - затем пользовательский файл .psqlrc.
    Пользовательский файл должен располагаться в домашнем каталоге, а расположение системного скрипта можно узнать командой:
    student$ pg_config --sysconfdir
    /etc/postgresql-common
    По умолчанию оба файла отсутствуют.

## Службы(процессы) Postgres
- autovacuum worker - служба для автоматического удаления и очестки от удаленных или отменненных данных
- walwritter - записывает журналы WAL на диск
- checkpointer - периодически сбрасывающий все грязные буферы на диск
- bgwriter - записывает только часть грязных буферов, причем те, которые с большой вероятностью будут вытеснены в ближайшее время
- stats collector - ему передается вся статистика от транзакций.
- archiver - Занимается архивацией WAL файлов.

## Работа с пользователями.
- Создать пользователя.Ссылка на атрибу снизу.
  ```
  CREATE ROLE роль [WITH] атрибут;
  ```

- Включение в роль .К примеру включить в роль admins пользователя joe.
  ```
  GRANT admins TO joe;
  ```
- Если пользователь включен в в другую группу с правами,то надо текущему пользовтаелю переключиться на эту роль,выполнить задачи и вернуться в свою роль.Описание всех ролей внизу в ссылке.
  ```
  SET ROLE student;
  SELECT session_user, current_user;
  RESET ROLE;
  SELECT session_user, current_user;
  ```
- Дать привелегия на базу
  ```
  GRANT ALL PRIVILEGES ON DATABASE "database1" to joe;
  \c database1
  GRANT pg_read_all_data TO joe;
  GRANT pg_write_all_data TO joe;
  ```
## работа с базами
- Создать базу из шаблоан 0
  ```
  createdb -T template0 имя_базы
  ```
- 
## Простые команды

- Получить список по кластерам SQL
```
pg_lsclusters
```
-Получить состояние кластера
```
/usr/lib/postgresql/14/bin/pg_controldata -D /var/lib/postgresql/14/main/
```


- Перезагрузить файл конфига.
```
SELECT pg_reload_conf();
```

- Команда управления postgresql
```
psql
```
- Управление кластером Postgres.pg_ctlcluster является обеткой(скриптом) над pg_ctl.
```
pg_ctl
pg_ctlcluster
```
Пример команд:
pg_ctlcluster версия имя_кластера действие
```
pg_ctl reload(stop,start)
pg_ctlcluster 13 main stop
```
### Важные таблицы
- Таблица pg_settings показывает текущую конфигурауию сервера.
 ```
 select * from pg_settings;
 select * from pg_settings \gx
 ```
- Таблица pg_file_settings показывает содержимое файлов конфигурации
 ```
  SELECT *  FROM   pg_file_settings ;
 ```
  или
 ```
 SELECT sourceline, name, setting, applied
 FROM pg_file_settings
 WHERE sourcefile LIKE '/etc/postgresql/13/main/postgresql.conf'
 ``` 
-  Получить весь список таблиц пердаствления
 ```
 \dv pg_catalog.*
 ```
- Получить информациию о текущей активности процесса, включая его состояние и текущий запрос.Пожно посмотреть блокировки,пользователей.
```
SELECT * FROM pg_stat_activity
```
-  
------------
## Полезные запросы

- Закрыть все соединения у БД     
SELECT pg_terminate_backend(pg_stat_activity.pid)     
FROM pg_stat_activity   
WHERE pg_stat_activity.datname = 'testbd' AND pid <> pg_backend_pid();   

- Посмотреть все права пользователя
  ```
  SELECT table_catalog, table_schema, table_name, privilege_type
  FROM information_schema.table_privileges
  WHERE grantee = 'username';
  ```
- Убить процесс зная его pid
  ```
  SELECT pg_terminate_backend(b.pid)
  FROM unnest(pg_blocking_pids(16746)) AS b(pid);
  ```
- Посотреть все индексы.
  ```
   select * from  pg_indexes;
  ```

- Глобальная статистика по всей базе данных
```
SELECT *
FROM pg_stat_database
WHERE datname = 'admin_monitoring' \gx
```
- Получить список всех таблиц
  ```
  select * from pg_tables;
  ```
- Получить список всех баз.
  ```
  select * from  pg_database;
  ```
- Получить размер бд
  ```
   SELECT pg_size_pretty(pg_database_size('appdb'));
  ```
- 
- Посмотреть значение буферного кеша.
  ```
  SHOW shared_buffers;
  ```
- Посмотреть использовался ли буферный кеш и если использовался то сколько .
  ```
  EXPLAIN (analyze, buffers, costs off, timing off)
  SELECT * FROM t;
  ```
- Посмотреть текущую позицию в журнале WAL.
  ```
  SELECT pg_current_wal_lsn();
  ```
- получить размер изменения между 2 журналами в байтах
  ```
  SELECT '0/345C978'::pg_lsn - '0/3459948'::pg_lsn AS bytes;
  ```
- посмотреь файлы WAL в папке
  ```
  SELECT * FROM pg_ls_waldir() ORDER BY name;
  ```
- 
-----
###  короткие команды PSQL   
\set - вывести все переменны   
\i - выполнить команды из файла   
\o - пеерключить вывпод в файл   
\\! - выполнение команд из OS (к примеру  cat,pwd и тд)   
\echo :{?workdir} - Данная конструкция :{? } проверяет существует ли данная переменная и возвращает TRUE или FALSE.
\gexec - Выполнить результат запроса.У примеру можно сформировать завпрос на олученеи таблицы и вполнить его не обязательно сохраняя в файл.К примеру запрос ниже сформирует получание количества строк в таблице   
      ```
      SELECT format('SELECT count(*) FROM %I;', tablename)   
      FROM pg_tables LIMIT 3   
      \gexec   
      ```
-------------
 ## Файлы и папки
- pg_xact.Лежит в $PGDATA (/var/lib/postgresql/15/main/).В нем лежат файлы статусов транзакций в системе.
- PGDATA/pg_stat_tmp и PGDATA/pg_stat - тут лежат файлы статистики собранные от процесса  stats collector
- ~/.pgpass.Лежит на клиенте (который хочет подключаться к серверу) в профиле.Разрешение на файл должно быть 0600(В системах Unix разрешения .pgpass должны запрещать чтение его всеми или группой; этого можно добиться командой chmod 0600 ~/.pgpass. Если разрешения будут менее строгими, этот файл не будет прочитан). Формат записи указан ниже.   
  ```
  сервер:порт:база_данных:имя_пользователя:пароль
  ```
- 

-----
Рекомендации к настройке
- Буферный кеш выставлять 1/4 от размера оперативки.Изменяется в файле postgres.conf - shared_buffers=..
- пароль зранить не в md5 а в scram-sha-256.Для этого надо зайти в базу и поменять тип хранимых паролей:
  ```
  SHOW password_encryption;
  SET password_encryption='scram-sha-256';
  ```
- 
--------
### Бэкопирование

**Логическое**
1. Есть команда COPY.Данные из таблицы выгружаются для переноса и вставки в таблицу (таблицы и колонки уже должны быть созданы)
  ```
  
  ```
2. pg_dump.При резервном копировании может выгрушать всю базу,таблиц,схемы,DML,DDLи тд.Вышружает либо в файл в виде SQL скрипта,либо в архив с заголовками.Если вышузить в архив с заголовкаими, то можно при восстановлении указать то именно нужно загружать.При создании бэкапа можно указать несколько процессов и каждый процесс может одновременно выгружать только 1 таблицу.
Для Восстановления используется команда pg_restore.Новая база данных должна создаваться из  шаблона template0и должны быть созданы роли и табличные пространства (pg_dump их не выгружает).
Выгрузка базы данных mydb в файл SQL-скрипта:
```
$ pg_dump mydb > db.sql
```
Восстановление из ранее полученного скрипта в чистую базу newdb:
```
$ psql -d newdb -f db.sql
```
Выгрузка базы данных в специальном формате:
```
$ pg_dump -Fc mydb > db.dump
```
Выгрузка базы данных в формате каталога:
```
$ pg_dump -Fd mydb -f dumpdir
```
Выгрузка базы данных в формате каталога в 5 параллельных потоков:
```
$ pg_dump -Fd mydb -j 5 -f dumpdir
```
Восстановление из архива в чистую новую базу данных newdb:
```
$ pg_restore -d newdb db.dump
```
Выгрузка отдельной таблицы mytab:
```
$ pg_dump -t mytab mydb > db.sql
```
3. pg_dumpall.В отличии от прошлой программы выгражает весь кластер включая роли и табличное пространство.
   ```
   pg_dumpall > db.out
   восстановить
   psql -f db.out postgres
   ```
**Физическое**

  1. Выключить сервер Postgre и скопировать каталог с данными.Файлы WAL не используются.НАзывается холодным
  2. Копируем файлы на включенном сервере + нужны WAL.Называется Горячей.Используется pg_basebackup.
     pg_basebackup -  утилита для резервного бэкопирования:
     подключается к серверу по протоколу репликации
     выполняет контрольную точку
     копирует файловую систему в указанный каталог
     сохраняет все сегменты WAL, сгенерированные за время копирования
     Команды:
     ```
     pg_lsclusters
     pg_basebackup --pgdata=/home/student/basebackup
     mv /home/student/basebackup/ /var/lib/postgresql/15/replica
     chown -R postgres:postgres /var/lib/postgresql/15/replica
     pg_ctlcluster 13 replica start
     ```
## Архивы  WALL
Существует 2 типа архивов: файловый и потоковый.

**Файловый**
  Сегменты WAL копируются в архив по мере заполнения
  механизм работает под управлением сервера
  неизбежны задержки попадания данных в архив
Для включения этого режима в postgre.conf нужно:
Параметры
wal_level = replica 
archive_mode = on
archive_command  - команда shell для копирования сегмента WALв отдельное хранилище
#archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'  # Unix - Пример команды
>символы %p заменяются полным путём к файлу, подлежащему архивации, а %f заменяются только именем файла. (Путь задаётся относительно текущего рабочего каталога, т. е. каталога данных кластера). Если в >команду нужно включить сам символ %, запишите %%. Простейшая команда, которая может быть полезна:

Алгоритм работы:
Общий алгоритм таков. При заполнении очередного сегмента WAL вызывается команда копирования. Если она завершается с нулевым статусом, то сегмент может быть удален. Если же нет, то сегмент(и следующие за ним) не будет удален, а сервер будет периодически пытаться выполнить команду, пока не получит 0. 

**Потоковый**
Утилита pg_receivewalподключается по протоколу репликации (можно использовать слот)и направляет поток записей WAL в файлы-сегменты
стартовая позиция — начало сегмента, следующего за последним заполненным сегментом, 
найденным в каталоге,или начало текущего сегмента сервера, если каталог пустой
в отличие от файлового архива, записи пишутся постояннопри переходе на новый сервер надо перенастраивать параметры.
>Утилита pg_receivewal подключается к серверу по протоколу потоковой репликации. Подключение обрабатывается отдельным процессом wal sender (это необходимо учесть при установке параметра >max_wal_senders).Утилита записывает данные, не дожидаясь получения всего сегмента

## Посмотреть статус
Статус работы репликации можно посмотреть следующими командами.

На мастере:
```
=# select * from pg_stat_replication;
```
На слейве:
```
=# select * from pg_stat_wal_receiver;
```

--------
- Посмотеть описание таблиц связанных со статистикой   
   https://postgrespro.ru/docs/postgresql/16/monitoring-stats#MONITORING-PG-STAT-REPLICATION-SLOTS-VIEW
- Описание трибутов у создавайемой роли   
  https://postgrespro.ru/docs/postgresql/9.6/sql-createrole
- Системный каталоги и их описание   
  https://postgrespro.ru/docs/postgresql/9.5/catalogs-overview
- Таблица с ролями   
  https://postgrespro.ru/docs/postgresql/16/predefined-roles
- Файл паролей   
  https://postgrespro.ru/docs/postgrespro/9.5/libpq-pgpass
- 
